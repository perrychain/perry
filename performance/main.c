#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "lib/cJSON/cJSON.h"
#include "common.h"

// 3rd party ed25519 library
/*
#include "lib/ed25519/src/ed25519.h"
#include "lib/ed25519/src/ge.h"
#include "lib/ed25519/src/sc.h"

// base64 encoder/decoder
#include "lib/base64/base64.h"
*/

// libsodium
#include <sodium.h>

#define MAX_MSG_LEN 1024

int main(int argc, char *argv[])
{

    if (sodium_init() < 0)
    {
        printf("Sodium LIBRARY FAILED!\n");
        exit(0);
    }

    if (argc == 2)
    {
        printf("The DB supplied is %s\n", argv[1]);
    }
    else if (argc > 2)
    {
        printf("Too many arguments supplied.\n");
    }
    else
    {
        printf("Specify blockchain-db.json to parse as an argument.\n");
        exit(0);
    }

    printf("LAUNCHING Perry CPU verification\n");

    FILE *fp;
    char *line = NULL;
    size_t len = 0;
    ssize_t read;
    cJSON *record = NULL;

    // Read a specified blockchain-db generated by Perry
    fp = fopen(argv[1], "r");
    if (fp == NULL)
        exit(EXIT_FAILURE);

    int lines = 0;

    while ((read = getline(&line, &len, fp)) != -1)
    {
        lines++;
    }

    printf("Number of lines %d\n", lines);

    // Rewind to scan the entire contents via cJSON
    rewind(fp);

    int blockid = 0;
    int i = 0;

    TxPayload *payload = malloc(1024 * sizeof *payload);

    while ((read = getline(&line, &len, fp)) != -1)
    {

        printf("Retrieved line of length %zu:\n", read);

        record = cJSON_Parse(line);
        // printf("%s\n", cJSON_Print(record->child));

        // int payload_len = cJSON_GetArraySize(record->child->next->child->next);
        //  printf("Payload length = %d\n", payload_len);

        BlockKV blockkv = {};

        blockkv.key = (unsigned char *)record->child->valuestring;

        const cJSON *r1 = NULL;

        // TODO: Calculate entry hash
        /*
        unsigned char hash[32] = {};

        i2 = 0;

        cJSON_ArrayForEach(r1, record->child)
        {
            hash[i2] = r1->valueint;
            printf("Key = %d\n", r1->valueint);
        }


        int n = sizeof(hash);
        printf("N => %d", n);
        char chars[n + 1];
        memcpy(chars, hash, n);
        chars[n] = '\0'; // Null-terminate the string

        printf("HASH = %s\n", &chars[3]);
        */

        cJSON_ArrayForEach(r1, record->child->next->child->next)
        {

            cJSON *sender = cJSON_GetObjectItemCaseSensitive(r1, "sender");
            cJSON *sig = cJSON_GetObjectItemCaseSensitive(r1, "signature");
            cJSON *data = cJSON_GetObjectItemCaseSensitive(r1, "data");

            payload[i].Sender = (const char *)sender->valuestring;
            payload[i].Signature = (const char *)sig->valuestring;
            payload[i].Data = (const char *)data->valuestring;

            uint8_t message[376];

            unsigned char *private_key;
            unsigned char *public_key;
            unsigned char *signature;

            private_key = calloc(512, sizeof(private_key));
            public_key = calloc(512, sizeof(public_key));
            signature = calloc(512, sizeof(signature));
            memset(message, '\0', sizeof message);

            // Public key
            public_key = mybase64_decode(payload[i].Sender);

            // Signature
            signature = mybase64_decode(payload[i].Signature);

            // Specify the message
            snprintf((char *)message, 376, "%s", mybase64_decode(payload[i].Data));

            int status;

            // Verify the provided signature matches the public key
            status = crypto_sign_verify_detached(signature, message, sizeof(message), public_key);

            if (status == 0)
            {
                printf("\nBlock %d => Transaction %d => Signature verification status => OK\n", blockid, i);
            }
            else
            {
                printf("\nBlock %d => Transaction %d => Signature verification status => FAIL\n", blockid, i);
            }

            free(sig);
            free(public_key);
            free(private_key);

            free(sender);
            free(signature);
            free(data);

            i++;
        }

        blockid++;
    }

    fclose(fp);

    exit(EXIT_SUCCESS);
}
